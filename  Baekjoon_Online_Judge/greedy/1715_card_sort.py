'''
문제
정렬된 두 묶음의 숫자 카드가 있다고 하자.

각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다.

이를테면, 20장의 숫자 카드 묶음과 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.

매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다.

이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다.

예를 들어 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤,

합친 30장 묶음과 40장을 합친다면 (10 + 20) + (30 + 40) = 100번의 비교가 필요하다.

그러나 10장과 40장을 합친 뒤, 합친 50장 묶음과 20장을 합친다면 (10 + 40) + (50 + 20) = 120 번의 비교가 필요하므로 덜 효율적인 방법이다.

N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다.

숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.

출력
첫째 줄에 최소 비교 횟수를 출력한다.

생각
10 20 30 40 50 70

정렬된 데이터를
두개씩 꺼내서
합산한 값을 구하고
그 값을 리스트에 저장해두고
합산한 값을 다시 넣어서 뒤에 값과 합한뒤
그 값을 계속 리스트에 저장하는 방식

하지만 합산된 값을 다시 넣을때 마다 정렬이 다시 진행되어야 하므로
리스트 보다는
리스트보다는 우선순위 큐를 통해서 코딩하는것이 좋음

'''
import heapq
import sys
n = int(sys.stdin.readline())
s = []
for _ in range(n):
    heapq.heappush(s, int(sys.stdin.readline())) #힙에 요소 추가하기

if n == 1 :
    print(0) #아;;; 하나 들어왔을때는 비교할필요가 없어서 0임...

else:
    v = 0
    while len(s) > 1:
        t = heapq.heappop(s) + heapq.heappop(s) # 값 두가지를 꺼내서 더한값
        heapq.heappush(s , t) # 그값을 다시 힙에다가 넣어줌 (힙정렬이 이루어짐)
        v += t # 합산값을 계속 더해서 유지하고있어야함.
    print(v)